---
layout: post
typora-root-url: ../qiujingbao.github.io
title: RISC-V 基本知识
---

## RISC-V

### 基础指令集

指令格式，分为六种。对于计算指令来说，操作的东西就三种 内存，立即数，寄存器。由于RISCV的特性，内存必须先访存后才能操作，所以能操作的就是寄存器和立即数，立即数又分为两种短立即数与长立即数。所以

| 名称     | 操作数             |      |
| -------- | ------------------ | ---- |
| R 类型   | 寄存器-寄存器操作  |      |
| S 类型   | 访存load指令       |      |
| I 型     | 短立即数和访存load |      |
| B 类型   | 条件跳转           |      |
| J 型指令 | 无条件跳转         |      |
| U 型     | 长立即数           |      |

特点：

​	首先，RISCV没有x86一样的从内存计算指令，如果数据涉及到内存必须先访存在计算。

第一，指令只有六种格式，并且所有的指令都是 32 位长

第二，RISC-V 指令提供三个寄存器操作数

第三，在 RISC-V 中对于所有指 令，要读写的寄存器的标识符总是在同一位置，意味着在解码指令之前，就可以先开始访 问寄存器。

第四，这些格式的立即数字段总是符号扩展，符号位总是在指令中最高位。

### 寄存器

​	列出了 RV32I 寄存器以及由 RISC-V 应用程序二进制接口（ABI assemble binary interface）所定义的寄存器名称。

​	RV32I 有 31 寄存器加上一个值恒为 0 的 x0 寄存器，与之相 比，ARM-32 只有 16 个寄存器，x86-32 甚至只有 8 个寄存器。

##### 寄存器可以分为调用者寄存器和被调用者寄存器。

​	所谓调用者寄存器和被调用者寄存器，是指明了责任。在发生函数调用时，都知道需要修改对应的寄存器。所谓调用者寄存器是指发起调用的一方负责保存寄存器的内容。同理被调用者寄存器就是，被调用的一方需要恢复的寄存器。

```
函数A调用了函数B，寄存器rbx在函数B中被修改了，逻辑上%rbx内容在调用函数B的前后应该保持一致，

解决这个问题有两个策略，
(1)在函数A在调用函数B之前提前保存寄存器%rbx的内容，执行完函数B之后再恢复%rbx的内容，这个
   策略就称为调用者保存；
(2)函数B在使用寄存器%rbx，先保存寄存器%rbx的值，在函数B返回之前，要恢复寄存器%rbx原来存储
   的内容，这种策略被称之为被调用者保存。
```

RISCV寄存器命名从x0-x31一共三十二个。如下图所示。

![图片来自 RISC-V-Reader-Chinese-v2p1，第 30 页](./assets/pics/%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%20RISC-V-Reader-Chinese-v2p1%EF%BC%8C%E7%AC%AC%2030%20%E9%A1%B5-9043809.png)

简单分为如下几类

| Register | ABI Name | Saver  | 作用               | preserved across call |
| :------- | :------- | :----- | :----------------- | --------------------- |
| x0       | zero     | —      | 硬编码恒为0        | -                     |
| x1       | ra       | Caller | 函数调用的返回地址 | n                     |
| x2       | sp       | Callee | 堆栈指针           | y                     |
| x3       | gp       | —      | 全局指针           | -                     |
| x4       | tp       | —      | 线程指针           | -                     |
| x5-7     | t0-2     | Caller | 临时寄存器/        | n                     |
| x8       | s0/fp    | Callee | 保存寄存器/帧指针  | y                     |
| x9       | s1       | Callee | 保存寄存器         | y                     |
| x10-11   | a0-1     | Caller | 函数参数/返回值    | n                     |
| x12-17   | a2-7     | Caller | 函数参数           | n                     |
| x18-27   | s2-11    | Callee | 保存寄存器         | y                     |
| x28-31   | t3-6     | Caller | 临时寄存器         | n                     |

Caller 由调用者保存，被调用者就可以随便更改。

Callee 由被调用者保存

​	举例，Return address寄存器，ra寄存器是Caller Saved，它导致了当函数a调用函数b的时侯，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。

##### 相关问题

**返回值可以放在a1寄存器吗？**

如果一个函数的返回值是long long型，也就是128bit，我们可以把它放到一对寄存器中。这也同样适用于函数的参数。所以，如果返回值超过了一个寄存器的长度，也就是64bit，我们可以将返回值保存在a0和a1。但是如果你只将返回值放在a1寄存器，我认为会出错。

**为什么寄存器不是连续的？比如为什么s1与其他的s寄存器是分开的？**

TA：我之前提到过，但是也只是我的猜想，我并不十分确定。因为s1寄存器在RISC-V的Compressed Instruction是可用的，所以它才被分开。

**除了Stack Pointer和Frame Pointer，我不认为我们需要更多的Callee Saved寄存器。**

TA：s0 - s11都是Callee寄存器，我认为它们是提供给编译器而不是程序员使用。在一些特定的场景下，你会想要确保一些数据在函数调用之后仍然能够保存，这个时候编译器可以选择使用s寄存器。

### 函数调用

注意如下寄存器指的是在函数调用过程中起到的作用，例如a7寄存器在interrupt传递中断号，但是函数调用过程中是传递参数。

函数调用过程：

1. 将参数存储到函数能够访问到的位置；（按序将参数放到a0-a7寄存器中）

2. 跳转到函数开始位置（使用 RV32I 的 jal 指令）；（pc寄存器修改为函数其实地址）

3. 获取函数需要的局部存储资源，按需保存寄存器；（被调用者需要保存sp指针等，因为需要恢复调用者的环境，其实是保存callee寄存器）

4. 执行函数中的指令；（step by step）

5. 将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部存储资源； （恢复寄存器）

6. 返回调用函数的位置（使用 ret 指令）（jump回去）

#### 链接

- **第一步 地址与空间分配**
  扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。
- **第二步 符号解析与重定位**
  使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。

**静态链接与动态链接**

静态链接：在程序运行前所有的库都进行了链接和加载

动态链接：外部的函数在第一次被调用时才会加载和链接，每次程序开始运行，它都会按照需要链接最新版本的库函数。另外，如果 多个程序使用了同一个动态链接库，库代码在内存中只会加载一次。

**静态链接优缺点：**

**缺点：**

如果这样的库很大，链接一个库到多个程序中会十分占用内存。

链接时库是绑定的，即使它们后来的更新修复了 bug，强制的静态链接的代码仍然会使用旧的、有 bug 的 版本。

**优点：**

依赖性较低

**动态链接优缺点：**

1. 减少了包体积

1. 减少了内存占用

1. 减少了静态链接耗时

但带来了以下缺点：

1. 更慢的启动耗时（将链接过程从编译时改为运行时）

1. 更多的脏内存（每个动态库都有自己的 DATA ）

#### 动态链接的基本实现

动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。

目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 **动态共享对象（DSO，Dynamic Shared Objects）**，一般以`.so`为后缀；在Windows中，动态链接文件被称为 **动态链接库（Dynamic Linking Library）**，一般以`.dll`为后缀。

在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 `/lib`目录下，文件名为 `libc.so`。整个系统只保留一份C语言动态链接文件`libc.so`，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的**动态链接器**会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。

#### 动态链接程序运行时地址空间分布

对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。

关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：

- **静态共享库（Static Shared Library）**（地址固定）
- **动态共享库（Dynamic Shared Libary）**（地址不固定）

**静态共享库**

静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在**某个特定的地址**划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为**静态**。

但是静态共享库的目标地址会导致地址冲突、升级等问题。

**动态共享库**

采用动态共享库的方式，也称为**装载时重定位（Load Time Relocation）**。其基本思路是：**在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。**

但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。

参考链接：

https://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/

### 特权架构

#### 机器模式，缩写为 M 模式，M-mode

​	m-mode是 RISC-V 中 hart（hardware thread，硬件线程）可以执行的最高权限模式。在 M 模式下运行的 hart 对内存，I/O 和一些对于启动和配 置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准 RISC-V 处理器都必须实现的权限模式。实际上简单的 RISC-V 微控制器仅支持 M 模式。机器模式最重要的特性是拦截和处理异常的能力。

​	**异常：**

​	**同步异常**：这类异常在指令执行期间产生，如访问了无效的存储器 地址或执行了具有无效操作码的指令时。

​	**中断**：它是与指令流异步的外部事件， 比如鼠标的单击。

​	有三种标准的中断源：**软件、时钟和外部来源**。软件中断通过向内存映射寄存器中存 数来触发，并通常用于由一个 hart 中断另一个 hart（在其他架构中称为处理器间中断机 制）。当 hart 的时间比较器（一个名为 mtimecmp 的内存映射寄存器）大于实时计数器 mtime 时，会触发时钟中断。外部中断由平台级中断控制器（大多数外部设备连接到这个 中断控制器）引发。

![图片来自 RISC-V-Reader-Chinese-v2p1，第 102 页](./assets/pics/%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%20RISC-V-Reader-Chinese-v2p1%EF%BC%8C%E7%AC%AC%20102%20%E9%A1%B5.png)

​	**如何处理异常？**

RISCV拥有八个控制状态寄存器 CSR

-  mtvec（Machine Trap Vector）它保存发生异常时处理器需要跳转到的地址。 
-  mepc（Machine Exception PC）它指向发生异常的指令。 
-  mcause（Machine Exception Cause）它指示发生异常的种类。
-  mie（Machine Interrupt Enable）它指出处理器目前能处理和必须忽略的中断。 
-  mip（Machine Interrupt Pending）它列出目前正准备处理的中断。 
-  mtval（Machine Trap Value）它保存了陷入（trap）的附加信息：地址例外中出错
-  的地址、发生非法指令例外的指令本身，对于其他异常，它的值为 0。 
-  mscratch（Machine Scratch）它暂时存放一个字大小的数据。 
-  mstatus（Machine Status）它保存全局中断使能，以及许多其他的状态

当中断产生时，对应的mstatus被置位，随后进行自动转换如下：

- 异常指令的 PC 被保存在 mepc 中，PC 被设置为 mtvec。 
- 根据异常来源设置 mcause，并将 mtval 设置为出错的地址或者其它适用于特定异常的信息字。
- 把控制状态寄存器 mstatus 中的 MIE 位置零以禁用中断，并把先前的 MIE 值保留到 MPIE 中。 
- 发生异常之前的权限模式保留在 mstatus 的 MPP 域中，再把权限模式更改为 M。

#### 用户模式（U 模式）

​	U模式尝试执行 M 模式指令或 访问 CSR 的时候产生非法指令异常。其它时候，U 模式和 M 模式的表现十分相似。通过 将 mstatus.MPP 设置为 U，然后执行 mret 指令，软件可以 从 M 模式进入 U 模式。如果在 U 模式下发生异常，则把控制移交给 M 模式。

#### 监管者模式（S 模式）

​	旨在支持现代类 Unix 操作系统，如 Linux，FreeBSD 和 Windows。S 模式比 U 模式权 限更高，但比 M 模式低。S 模式下运行的软件不能使用 M 模式的 CSR 和 指令，并且受到 PMP 的限制。

PMP参考：https://tinylab.org/riscv-pmp-1/

s模式的异常处理过程：

- 发生例外的指令的 PC 被存入 sepc，且 PC 被设置为 stvec。

- scause 设置异常类型，stval 被设置成出错的地址或者其它特定异常的信息字。

- 把 sstatus CSR 中的 SIE 置零，屏蔽中断，且 SIE 之前的值被保存在 SPIE 中。

- 发生例外时的权限模式被保存在 sstatus 的 SPP 域，然后设置当前模式为 S 模式。


​	默认情况下，发生所有异常（不论在什么权限模式下）的时候，控制权都会被移交到 M 模式的异常处理程序。但是 Unix 系统中的大多数例外都应该进行 S 模式下的系统调 用。M 模式的异常处理程序可以将异常重新导向 S 模式，但这些额外的操作会减慢大多数 异常的处理速度。因此，RISC-V 提供了一种**异常委托机制**。通过该机制可以选择性地将中 断和同步异常交给 S 模式处理，而完全绕过 M 模式。

**为什么处理器架构在设计时需要设计好几种级别不同的模式呢？**

​	保证系统的安全性

​	原因是为了不同作用的程序考虑的。比如一般操作系统享有最高级别的权限，可以访问系统所有硬件，执行所有特权指令，例如设置MMU页表等，那么设置MMU页表这种操作能让普通的应用程序来操作吗，当然是不行的，所以操作系统和普通应用这两种程序肯定是需要运行在不同级别的权限模式下的，如果普通程序强行去执行特权指令操作，要么没有任何反应要么系统产生异常，这样就从硬件上保证了安全性。

**为啥RISCV架构特权模式设计成三级，直接把M模式和S模式合二为一不行吗？**

​	为了兼容微处理器与大型计算机。

​	这个得从RISCV架构诞生背景来看了，RISCV架构诞生于2010年左右，这时不管是x86还是arm架构都发展得算是比较成熟了，所以RISCV架构设计时就定位了从微控制器到大型超级计算机都可以使用这个架构。在微控制器上使用的RISCV架构一般只有M模式，或者使用M和U两种模式，类似于cortex-m架构的定位；而在带MMU的芯片上，RISCV架构一般都使用M、S和U三种模式，这样通过“拼积木”的方式就可以让RISCV架构适用于各种场景了。

**U 与 S 之间的切换[#](https://www.cnblogs.com/harrypotterjackson/p/17548837.html#3226483630)**

**U 切换到 S[#](https://www.cnblogs.com/harrypotterjackson/p/17548837.html#405839637)**

当执行一个 trap 时，除了 timer interrupt，所有的过程都是相同的，硬件会自动完成下述过程：

1. 如果该 trap 是一个设备中断并且 `sstatus` 的 SIE bit 为 0，那么不再执行下述过程
2. 通过置零 SIE 禁用中断
3. 将 pc 拷贝到 `sepc`
4. 保存当前的特权级到 `sstatus` 的 SPP 字段
5. 将 `scause` 设置成 trap 的原因
6. 设置当前特权级为 supervisor
7. 拷贝 `stvec`（中断服务程序的首地址）到 pc
8. 开始执行中断服务程序

CPU 不会自动切换到内核的页表，也不会切换到内核栈，也不会保存除了 pc 之外的寄存器的值，内核需要自行完成。对于Linux而言，内核空间与用户态空间是使用的同一套页表，不需要切换页表。详情可以参考用户态进程的虚拟内存布局。内核空间一般位于进程的高虚拟地址空间。

对于没有开启分页，如何切换特权级可以参考：[实现特权级的切换 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html)

如果启用了分页，当陷入到 S 模式时，CPU 没有切换页表（换出进程的页表，换入内核页表），内核需要自行切换页表，参考：[内核与应用的地址空间 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/5kernel-app-spaces.html) 和 [基于地址空间的分时多任务 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/6multitasking-based-on-as.html) 。

其实切换页表的过程也很简单，只需要将内核的页表地址写入 `satp` 寄存器即可。

在执行中断服务例程时还需要首先判断 `sstatus` 的 SPP 字段是不是 0，如果是 0 表示之前是 U 模式，否则表示 S 模式。如果 SPP 是 1 那就出现了严重错误（因为既然是从 U 切换到 S 的过程，怎么可以 SPP 是 S 模式呢？当然，如果是内核执行时发生了中断 SPP 是 1 那自然是对的，内核执行时发生中断时如果检查 SPP 是 0 那也是严重的错误）。

**S 切换到 U[#](https://www.cnblogs.com/harrypotterjackson/p/17548837.html#507506963)**

​	在从 S 切换到 U 时，要手动清除 `sstatus` 的 SPP 字段，将其置为零；将 `sstatus` 的 SPIE 字段置为 1，启用用户中断；设置 `sepc` 为用户进程的 PC 值（你可能疑惑在 U 转换到 S 时不是已经将用户进程的保存在了 `sepc` 了吗?因为在 S-mode 也会发生中断呀，那么 `sepc` 就会被用来保存发生中断位置时的 PC 了）。如果启用了页表，就需要想还原用户进程的页表，即将用户进程的页表地址写入 `satp`，之后恢复上下文，然后执行 `sret` 指令，硬件会自动完成以下操作：

1. 从 `sepc` 寄存器中取出要恢复的下一条指令地址，将其复制到程序计数器 `pc` 中，以恢复现场；
2. 从 `sstatus` 寄存器中取出用户模式的相关状态，包括中断使能位、虚拟存储模式等，以恢复用户模式的状态；
3. 将当前特权模式设置为用户模式，即取消特权模式，回到用户模式。

[回到顶部](https://www.cnblogs.com/harrypotterjackson/p/17548837.html#_labelTop)

**S 与 M 之间的切换[#](https://www.cnblogs.com/harrypotterjackson/p/17548837.html#3474172259)**

**S 切换到 M[#](https://www.cnblogs.com/harrypotterjackson/p/17548837.html#3699566859)**

S 切换到 M 与从 U 切换到 M 类似，都是从低特权级到高特权级的切换。在 S 运行的代码，也可以通过 `ecall` 指令陷入到 M 中。

1. S-mode 的代码执行一个指令触发了异常或陷阱，例如环境调用（ECALL）指令
2. 处理器将当前的 S-mode 上下文的状态保存下来，包括程序计数器 (PC)、S-mode 特权级别和其他相关寄存器，保存在当前特权级别堆栈中的 S-MODE 陷阱帧（trap frame，其实就是一个页面）中
3. 处理器通过将 mstatus 寄存器中的 MPP 字段设置为 0b11（表示先前的模式是 S 模式）将特权级别设置为 M-mode
4. 处理器将程序计数器设置为在 M-mode 中的陷阱处理程序例程的地址
5. 处理器还在 mstatus 寄存器中设置 M-mode 中断使能位 (MIE) 为 0，以在陷阱处理程序中禁用中断

**系统调用的实现**

​	系统调用是利用异常机制实现的。在 `mcause` 中我们看到有 Environment call from U-mode 和 Environment call from S-mode 两个异常类型。那么如何触发这两个异常呢？分别在 U-mode 和 S-mode 执行 `ecall` 指令就能触发这两个异常了。

​	异常触发之后，就会被捕捉到 M-mode（我之前提过，RISC v 下默认是把所有的异常、中断捕捉到 M-mode，当且仅当对应的陷阱被委托给了其它模式才会陷入到被委托的模式中）。

#### 外中断

外部中断源由核外PLIC与CLIC产生，像arm的GIC(generic Interrupt Controller)



参考链接：

https://www.cnblogs.com/harrypotterjackson/p/17548837.html

https://www.cnblogs.com/harrypotterjackson/p/17548837.html